1. **Java - 정의**
    - **Java의 특징에 대해 설명해주세요**
        - (abstract) Java란, **객체지향 언어**로 개발된 프로그래밍 언어이다.
        기본 자료형을 제외한 모든 요소들이 객체로 표현되고, 객체 지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어이다.
        - 장점
            - **JVM(자바가상머신)** 위에서 동작하기 때문에 운영체제에 독립적이며, 이식성이 높다.
            - 즉, window,mac,리눅스 등에서도 동일한 자바코드로 동일하게 동작
            - 자동적인 메모리 관리가 가능하다.(C에서 포인터와 비교)
        - keyword : 객체지향, JVM
        - 조금 더 자세한 설명
        - (what?) Java란, 객체지향 언어로 개발된 프로그래밍 언어이다.
        기본 자료형을 제외한 모든 요소들이 객체로 표현되고, 객체 지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어이다.
        - (why?) 객체지향 언어이기 때문에, 유지보수가 쉽고 직관적인 코드 분석이 가능하다. 또한 C/C++처럼 배포될 운영체제에 맞게끔 크로스 컴파일해야하는 번거로움이 없기 때문에, 하나의 클래스 파일로 JVM이 설치된 모든 운영체제에서 동작이 가능하다는 편리함이 있다. 또한 메모리 관리 등을(포인터x) 자동으로 해주기 때문에 개발 속도 측면에서 효율적이다.
        - (why not?) 타 언어의 경우, 운영체제에 맞춰 개발환경 세팅이 필요한 경우가 많으며,  절차적 프로그래밍의 경우 유지보수가 어려우며 가독성이 떨어져 대형 프로젝트 진행 시 어려움이 많다.
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d1c71c6d-197e-4655-a5a1-a25f1779ccea/Untitled.png)
        
    
    Java의 실행방식
    
    - 자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어 자바 바이트코드(.class)로 변환시킵니다.
    - Class Loader를 통해 class 파일들을 JVM으로 로딩합니다.
    - 로딩된 class파일들은 Execution engine을 통해 해석됩니다.
    - 해석된 바이트코드는 Runtime Data Areas 에 배치되어 실질적인 수행이 이루어집니다.
    
    - **JVM의 역할에 대해 설명해주세요**
        - (abstract) JVM은 자바를 실행하기 위한 스택 기반 자바 가상 머신으로, Java Byte Code를 OS에 맞게 해석 해주는 역할을 하고 가비지컬렉션을 통해 자동적인 메모리 관리를 해준다.
        - (what?) 자바 가상 머신으로, 자바 바이트 코드를 OS에 특화된 코드로 변환한다.
        - (why?) 타 언어로 개발된 어플리케이션의 경우, JVM과 같은 가상머신 없이 OS에 종속되어 있기 때문에 다른 OS에서 실행하고자 할 경우, 애플리케이션을 그 OS에서 실행할 수 있도록 변경해야한다.JAVA의 경우, JVM이 OS와 직접적인 상호작용을 하기 때문에 OS에 맞춰 애플리케이션을 변경하지 않아도 되는 편리함이 있다.
        - (why not?) OS에 맞춰 애플리케이션 변경 필요
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/81c85e2e-00c4-4b5f-b4a7-ab6a12954c80/Untitled.png)
        
2. **Java - 오버라이딩/오버로딩**
    - **Overriding과 Overloading에 대해 설명해주세요**
        - 오버라이딩(Overriding)은 상위 클래스에 있는 메소드를 하위 클래스에서 재정의 하는 것을 말하고,
        - 오버로딩(Overloading)은 매개변수의 개수나 타입을 다르게 하여 같은 이름의 메소드를 여러 개 정의하는 것을 의미한다.
        - (why?) 오버라이딩을 쓰는 이유는, 하나의 메서드로 여러 각각의 객체에서 출력하고자 하는 것을 다르게 출력할 수 있어 활용성을 높일 수 있다.
        ex. 부모 클래스(동물) → 자식 클래스(오리/돼지) .
        동물.sound → return “울음소리”
        오리.sound → return “꽥꽥”
        돼지.sound → return “꿀꿀” —> sound 라는 메서드를 활용해 클래스마다 여러 소리를 정의가능
        - (why?) 오버로딩을 쓰는 이유는, 한 클래스 내 여러 개의 같은 이름의 메소드를 정의하므로써 프로그램의 가독성을 높일 수 있다.
        ex. println(int / String / boolean / char …) 등 어떤 인자를 받는 println으로 활용 가능.
        오버로딩이 없다면, printlnint(),printlmStirng()등 문자형에 따라 모두 다른 메서드 활용해야함.
        - 오버라이딩 : 메서드의 확장(커스터마이징)
        - 오버로딩 : 메서드의 일관성(동일한 동작 보장)
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cd561768-cc69-42b5-b48e-34924d34d2cb/Untitled.png)
    
3. **공통 - 객체 지향**
    - **객체지향 프로그래밍이란 무엇인지 설명해주세요**
        - (abstract) 객체 지향 프로그래밍은 상태와 행위를 가진 객체를 만들고 각각의 객체들의 역할이 무엇인지를 정의하여 객체들 간의 상호작용 과 의존성 관리를 통해 프로그램을 만드는 것을 말한다.
        즉, 객체를 통해 **"누가 어떤 일을 할 것인가?"**를 정의하는 것이 핵심이다. 특징으로는 캡슐화, 상속, 다형성, 추상화 등이 있고, 모듈 재사용으로 확장 및 유지보수가 용이하다.
        - (what?) 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.
        객체지향에서 가장 중요한 것은 DIP(Dependency Inversion Principle)를 통한 고수준 정책(High Level Policy)와 저수준 구현 세부사항(Low Level Details)의 분리라고 할 수 있다.
        왜냐하면, 객체지향으로 의존성을 관리함으로써 변경 영향을 최소화하고 독립적인 배포가 가능해지며 독립적인 개발이 가능해지기 때문이다.
        - (why?) 객체지향 언어이기 때문에, 유지보수가 쉽고 직관적인 코드 분석이 가능하다.
        - (why not?) 절차적 프로그래밍의 경우 유지보수가 어려우며 가독성이 떨어져 대형 프로젝트 진행 시 어려움이 많다.
        - (book : 객체 지향의 사실과 오해)
        - (extra) **객체 지향 프로그래밍 키워드**
            - 클래스/인스턴스(객체)
                - **클래스** : 어떤 문제를 해결하기 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 **속성**(attribute)과 **행위**(behavior)를 **변수**와 **메서드**로 정의한 것으로 객체를 만들기 위한 메타정보라고 볼 수 있다.
                - **인스턴스(객체)** : 클래스에서 정의한 것을 토대로 실제 메모리에 할당된 것으로 실제 프로그램에서 사용되는 데이터이다.
            - 추상화
                - 객체 지향 프로그래밍에서는 '추상화' 라는 단어를 여러 군데 붙일 수 있다.
                - 여기서 말하는 추상화는 추상 클래스나 추상 클래스가 갖는 추상 메서드를 의미하기보다는 클래스를 설계하는 것 자체를 의미한다.
                - 즉, "공통의" 속성이나 기능을 묶어 이름을 붙이는 것이다.
            - 캡슐화
                - **캡슐화의 목적 2가지**
                    
                    **1. 코드를 재수정 없이 재활용하는 것.**
                    
                    **2. 접근 제어자를 통한 정보 은닉**
                    
                    - 절차 지향 프로그래밍에서도 라이브러리를 통해서 변수와 함수를 재활용할 수는 있었지만, 코드의 수정이 일어났을 때 영향 범위를 예상하기 어려운 문제가 있었다.
                    그러나 객체 지향 프로그래밍에서는 캡슐화를 통해 객체가 외부에 노출하지 않아야할 정보 또는 기능을 접근제어자를 통해 적절히 제어 권한이 있는 객체에서만 접근하도록 할 수 있기에 코드의 수정이 일어났을 때 책임이 있는 객체만 수정하면 되기에 영향 범위를 예측하는데 수월해졌다.
                    - **뿐만 아니라 관련된 기능과 특성을 한 곳에 모으고 분류하기 때문에 객체 재활용이 원활**해졌다.객체 지향 프로그래밍에서 기능과 특성의 모음을 "클래스"라는 "캡슐"에 분류해서 넣는것이 캡슐화다. 객체가 맡은 역할을 수행하기 위한 하나의 목적을 한데 묶는다.
            - 상속
                - 부모클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게하고 기능의 일부분을 변경해야 할 경우 상속받은 자식클래스에서 해당 기능만 다시 수정(정의)하여 사용할 수 있게 하는 것이다.
            - 다형성
                - 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것이다.
                즉 오버라이딩(Overriding), 오버로딩(Overloading)이 가능하다는 얘기다.
    - **객체지향 설계원칙에 대해 설명해주세요(SOLID)**
        - **SRP** - 단일 책임 원칙 : 한 클래스는 하나의 책임만 가져야 한다.
        - **OCP** - 개방-폐쇄 원칙 : 확장에는 열려있고, 수정에는 닫혀있어야 한다.
        - **LSP** - 리스코프 치환 원칙 : 상위 타입은 항상 하위 타입으로 대체할 수 있어야 한다.
        → 억지로 상속관계 설정 지양
        - **ISP** - 인터페이스 분리 원칙 : 인터페이스 내에 메소드는 최소한 일수록 좋다. (하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다.)
        → 인터페이스의 교집합 지양
            
            SRP와 같은 문제에 대한 두 가지 다른 해결책이다.
            
        - **DIP** - 의존관계 역전 원칙 : 구체적인 클래스보다 상위 클래스, 인터페이스, 추상클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺어라.
            
            DIP 원칙을 따르는 가장 인기 있는 방법은 의존성 주입(DI)이다.
            
4. **Java - 인터페이스/ 추상 클래스**
    - **인터페이스와 추상 클래스의 정의에 대해 설명해주세요**
        - (abstract)추상 클래스는 클래스 내 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우를 말하고,인터페이스는 모든 메소드가 추상 메소드로만 이루어져 있는 것을 말한다.
        - 공통점
            - 메서드의 선언만 있고 구현 내용이 없는 추상메서드가 포함된다.
            - new 연산자로 인스턴스 생성 불가능
            - 사용하기 위해서는 하위 클래스에서 확장/구현 해야 한다.
        - (what?) 인터페이스란, interface 키워드를 사용하여 정의하며,추상 메서드의 집합이다. 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용한다.
        - (what?) 추상 클래스란, class 앞에 'abstract' 키워드를 사용하여 정의하며, 하나 이상의 추상 메서드를 가지는 클래스를 말합니다. 추상 메서드를 선언하여 상속을 통해서 하위 클래스에서 (반드시) 구현하도록 강제하는 클래스이다.
        - (why?)인터페이스와 추상 클래스를 사용하면, 상속을 통해 기존 인터페이스/추상 클래스에 있던 메서드 등을 재정의하여 활용할 수 있어 편리하다.
        - (why not?) 추상 클래스가 없다면, 같은 기능을 하는 메서드라도 매 클래스마다 일일이 정의하고 생성해줘야하는 불편함이 있다.
        - (why not?) 추상 클래스와 달리 인터페이스는 다중 상속이 가능하기 때문에 훨씬 유연한데, 인터페이스를 사용하지 않을 경우, 모호한 메서드를 모두 오버라이딩해야하는 불편함이 있다.
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/72892db8-123a-4d74-b9ee-a53964672164/Untitled.png)
        
    - **둘의 차이점에 대해 설명해주세요.**
    - 인터페이스는 추상 클래스와는 다르게 구현부가 있는 일반 메서드, 일반 멤버 변수를 가질 수 없다는 특징이 있다.
    - 인터페이스는 인터페이스에 정의된 메서드를 각 클래스의 목적에 맞게 기능을 **구현하도록 강제**한 것이다. 그렇기 때문에 implement를 쓴다.(기능 정의만 해두고(설계), 실제 구현은 클래스가 진행)
    구현을 강제함으로써 구현 객체의 같은 동작을 보장할 수 있다.
    - 추상클래스는 미리 논리적인 클래스 상속 구조를 만들어, 추상 클래스 내 정의된 기능 **확장**을 위해 사용한다. 그렇기 때문에 extends를 쓴다.(이미 있는 기능을 재사용)
    또한 추상클래스는 다중상속이 불가능하지만, 인터페이스는 다중상속이 가능하다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bcb2c3d7-24e2-48fb-9edf-dd2bb8980cb5/Untitled.png)
    
5. **Java - 클래스/객체/인스턴스**
    - **클래스와 객체, 인스턴스에 대해 설명해주세요**
        - 클래스는 객체를 만들어내기 위한 설계도 혹은 틀 이라고 할 수 있고, 객체를 생성하는데 사용한다.(클래스는 데이터파트와 메서드파트로 구분된다)
        - 객체는 설계도(클래스)를 기반으로 생성되며, 자신의 고유 이름과 상태, 행동을 갖는다.
        - 여기서 상태는 필드(fields), 행동은 메소드(Method)라고 표현.
        - 객체에 메모리가 할당되어 실제로 활용되는 실체는 '인스턴스'라고 부른다.

# OS

### 프로세스 & 스레드

**프로세스와 스레드의 차이**

과거에는 CPU와 운영체제에서 보는 작업의 기본적인 단위이자 최소 단위가 프로세스였다면, 이후 한 프로세스 내에서 여러 가지 과업을 진행해야 했기에, 이 필요에 따라 나중에 스레드가 프로세스의 내부에서 세분화된 것이다. 그래서 프로세스가 하나의 작업을 맡는다면 스레드는 그 내부에서 하나의 세부적인 flow 하나만을 담당하는 것이다. 그렇기에 프로세스마다 최소한 스레드가 하나는 있어야 한다. 그리고 프로세스는 원칙적으로 다른 프로세스에게 영향을 주지 않으나, 프로세스의 하위 구조인 스레드는 프로세스의 Code, Data, 그리고 Heap 의 메모리 영역을 공유하기 때문에 한 스레드에서 오류가 생겼을때 같은 프로세스 내의 다른 스레드들 또한 영향을 입는다.

**Context Switching**

컨텍스트 스위칭은 실행되고 있는 프로세스를 중단하고 다른 프로세스를 실행해서 교체하는 기술이다. 이름을 뜯어보면 Context를 교체한다는 것인데 여기서 Context란 CPU에서 프로세스를 실행하기 위한 각 프로세스의 정보이다.

Context는 Process Control Block에 저장되며, 저장되는 내용은

- 프로세스 상태
- 프로그램 카운터
- 레지스터
- 프로세스 번호

가 있다.

이를 활용해서 여러개의 프로세스를 마치 동시에 동작하는 것처럼 보이게 만들어 동시에 동작하는 것처럼 보이게 만든다. (멀티태스킹)

**Multithread Programming**

위에서 설명한 Thread를 한 Process에 2개 이상 가지는 것을 Multithreading이라고 하는데, 이를 통해 동시성을 향상시킬 수 있다. 이를 프로그래밍할 수 있는데,

### 임계영역 & 세마포어 & 뮤텍스

**Semaphore와 Mutex의 차이**

Semaphore와 Mutex 둘 다 임계영역에서의 충돌을 예방하는 역할을 수행하며 Mutex (Mutual Exclusion)는 동시에 하나의 프로세스 혹은 스레드만 이용할 수 있는 자원에, Semaphore는 복수의 프로세스, 스레드가 이용할 수 있는 경우에 사용한다. Mutex의 경우 특정 객체를 이용해서 그 자원을 이용중일땐 Lock을, 안할땐 Unlock을 해서 다른 프로세스 혹은 스레드가 이용할 수 있도록 한다. Semaphore의 경우는 동시에 허용 가능한 스레드의 수를 보관하며, 최대치만큼의 스레드들이 이용중일때 다른 스레드가 접근하려면 스레드 하나가 공유자원을 놔줬을 때 세마포어의 값이 업데이트되면서 접근할 수 있다.

**Thread-safe의 의미와 설계하는 법**

Java에서 멀티스레팅 프로그래밍을 했을 때, 프로세스의 공용자원을 여러 스레드에서 접근할때 데이터의 일관성이 유지될 수 있도록 하는 것이다.

Java의 `synchronized` 키워드를 사용하면 데이터에 접근중일때 Lock을 걸어 그 일관성이 손상되지 않도록 한다. method가 synchronized일때 그 객체에 Lock을 걸지만, static일땐 그 클래스에 Lock을 건다.  

### 교착상태 Deadlock

Deadlock이란 두 개 이상의 작업이 서로의 작업이 끝나기 만을 기다리고 있어  무한히 기다리게 되는 상황을 말한다. 상호배제, 점유대기, 비선점, 순환 대기 4가지 조건이 모두 만족할 때 발생할 가능성이 생긴다.

예방, 회피, 탐지, 복구 4가지 방법으로 해소할 수 있다.

- 예방: 저 4가지 조건 중 하나를 방지함으로서 교착상태를 예방할 수 있다.
- 회피: Safe state에서만 자원 요청을 허용한다. 여기서 safe state란 교착상태 없이 자원을 할당하는 순서가 존재하고 모든 프로세스가 문제없이 정상적으로 종료될 수 있는 상태를 일컫는다. 하지만 이를 위해서는 몇가지 조건이 필요하다;
    - 프로세스 수의 고정
    - 자원의 종류와 수가 고정
    - 프로세스가 요구하는 최대 자원의 수를 인지
    - 프로세스가 자원 사용하면 반드시 반납
    
    이를 위한 알고리즘이 은행원 알고리즘, 자원 할당 그래프 알고리즘
    
- 탐지: 데드락이 발생했는지에 대한 여부를 지속적으로 탐색, 발견되면 복구
지속적으로 교착상태를 체크하기 때문에 오버헤드 발생
- 복구: 교착상태를 해결하는 기법
    - 사용자 처리 : 교착상태 프로세스를 사용자가 종료
    - 시스템 처리 : 교착상태 프로세스를 하나씩/모두 종료, 혹은 프로세스들로부터 자원을 뺏어 교착상태 해결까지 다른 프로세스들에게 자원 할당

### 동기 & 비동기

동기, 비동기는 함수를 불렀을 때, 그 함수의 결과값을 기다리는가에 따라 정해진다. 동기는 그 결과값을 받을때까지 대기하고, 비동기의 경우 그 결과값을 기다리지 않고 계속 실행하되 그 함수의 종료와 동시에 콜백함수를 실행해서 그 결과값을 활용한 작업을 한다.

동기적 프로그래밍은 말그대로 순차적으로 위에서 아래로, 앞의 코드를 기다리는 방식이다. 앞의 코드가 끝나야 이후의 코드를 수행하기 때문에 비동기적인 코드보다 느리지만, 한방향으로만 진행하기 때문에 에러의 위치 파악이 수월하다.

비동기적 프로그래밍은 반대로 이전 코드의 결과를 기다리지 않고 수행하는 코드를 만든다. 이는 그 특성에 의해 속도가 매우 빠르며, 여러개의 긴 Request들을 동시다발적으로 보낼 수 있는 것이 장점이다.

### 블로킹 & 논블로킹

동기와 비동기에 이어서 블로킹, 논블로킹은 함수의 제어권이 요청과 함께 넘어가냐에 따라 정해진다. 블로킹은 함수를 호출할때 그 함수가 완료될때까지 대기해야하기에 그 제어권이 함수와 함께 넘어갔다고 본다. 논블로킹은 그와 반대로, 함수를 실행함과 상관없이 제어권을 유지하고 있어 차질없이 실행된다.

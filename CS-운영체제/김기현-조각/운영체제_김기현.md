### 프로세스 & 스레드 개념
1. 프로세스 & 스레드 개념
    1. 프로세스와 스레드의 차이를 설명해보세요.
    범위로 따지자면 프로세스 내부에서 스레드가 돌아간다고 볼 수 있다. 각각의 프로세스는 최소 1개의 스레드를 돌릴 수 있다.
    프로세스는 메모리 위에서 실행되고 있는 일종의 task이다. OS로 부터 리소스(Stack, Heap, Data, text)를 할당 받는다. 스레드는 프로세스가 할당받은 리소스를 직접 이용하고 실행한다.
    text : 바이너리 코드로 구성
    Data : 정적 데이터 예를 들어 전역 변수
    stack : 일시적인 로컬 데이터, 예를들어 함수의 파라미터, 리턴 주솟값, 로컬 변수
    Heap : 동적으로 할당되는 데이터, 예를들어 C언어의 malloc 으로 메모리를 할당받는 데이터나 자바의 객체 
    C로 코드를 작성할 떄 포인터를 사용하면 포인터 변수에 해당하는 주솟값은 Stack, 그리고 이 주솟값에 해당하는 데이터는 Heap. 보안적인 측면에서 보면 Heap 메모리 영역에 악성 코드를 주입한다고 한다...
    커널 코드에는 process의 데이터 PCB (리소스를 관리하거나 프로세스의 정보가 담겨진) 가 저장되고 OS에게 부여받은 메모리 영역위에서 프로세스가 돌아간다.

    2. 컨텍스트 스위칭
    먼저 컨택스트란 CPU 가 프로세스를 실행하면서 가지는 데이터 (PCB, 레지스터, Program Counter), 프로세스를 실행하기 위한 정보들, PCB에 저장된다. PCB에는 해당 프로세스가 종료된 시점(state)가 기록되고 다시 해당 프로세스를 실행할 떄 종료 시점 부터 실행 할 수 있다.
    커널을 통해 스위치가 일어나는데 해당 커널 내부에서 PCB에 end point state를 저장하고 실행할 프로세스의 state를 reload 한다. 이때 어떤 프로세스를 실행시킬지는 유저 프로세스가 아니라 OS가 선택한 스케쥴링 기법에 따라 결정하게 된다.
    Context Swithching Overhead : 컨텍스트 스위칭이 일어나는데 걸리는 time 이다. 스케쥴링 기법에 따라 이 time이 변하기 때문에 스케줄링에서 Overhead 를 핸들링하는 것이 중요하다. 
    OS에 의해서 프로세스가 바뀌어진다. 

    3. 멀티스레드 프로그래밍
    멀티스레드 프로세스 : 한 프로세스의 address space 에서 여러 threads가 running.
    멀티스레드 프로세스는 리소스를 공유(code(text)와 data)한다. 그리고 thread 마다 stack과 heap 영역을 가진다. 스택과 힙의 경우 프로세스가 OS로부터 부여받은 Stack과 Heap 영역에 여러집 살림한다고 생각하면 될 것 같다. 또한 하나의 프로세스이기 때문에 하나의 PCB 데이터만 생성된다. OS 입장에서는 process를 10개 만드는 것보다 thread를 10개 만드는 것이 가볍기 때문에 하나의 PCB안에 여러 thread 정보를 기록한다.  
    동시성과 평행성을 가진다.

2. 임계영역 & 세마포어 & 뮤텍스
    1. 임계영역 : 공유 자원에 대해 하나의 프로세스만 접근할 수 있도록 통제가 필요한 영역
    2. 세마포어와 뮤텍스 : 공유자원을 안전하게 관리하기 위해 상호배제를 달성하는 기법들
    3. 세마포어 : 자원에 접근할 수 있는 Signaling Mechanism을 기반으로 상호 배제를 달성
    4. 뮤텍스   : 자원에 접근할 수 있는 Key를 기반으로 상호배제를 달성

3. DeadLock 교착상태
    Dining-PhilosophersProblem: 다섯명의 철학자가 왼쪽의 젓가락을 집을려고 할때는 모든 젓가락은 할 당가능 이때 오른쪽의 젓가락을 할당 받으려고 하면 모든 철학자들이 영원히 할당 받지 못한다. 이를 DeadLock이라고 한다.
    DeadLock이 일어나기 위한 4가지의 필수 요건이 있다
    첫째, 상호배제          : 자원을 공유하지 않는 전제
    >> 자원을 공유할 수 있도록 만든다
    둘째, Hold and wait     : 한 프로세스는 최소 하나 이상의 리소스를 갖고 있고 
                            다른 리소스를 할당 받기 위해 대기하고 있는 상태여아 하는 전제
    >> 프로세스가 자원을 할당 받은 상태에서 다른 자원을 요청하는 일이 없도록 보장한다
    셋째, No preemtion      : OS가 강제적으로 할당을 박탈하는 일이 없어야함
    >> 일정 조건이 되면 자원을 강제적으로 뺏어버리도록 만든다
    넷째, Circular Wait     : 순환 상태여야 하는 전제
    >> 여유 자원을 만들어둔다.

4. 동기 & 비동기
    1. 동기와 비동기 차이
    동기는 요청이 주어질 때 응답을 받을 때까지 기다려야한다. 비동기는 요청이 주어지더라도 다른 활동을 할 수 있다.
    2. 동기 프로그래밍
    3. 비동기 프로그래밍
        대표적으로 Ajax가 있다. 비동기는 동시에 여러 task를 수행할 수 있는 것이다.
        https://hi-zini.tistory.com/entry/%EB%B9%84%EB%8F%99%EA%B8%B0%EC%A0%81-%EB%B0%A9%EC%8B%9D-%EC%B2%98%EB%A6%AC-%EB%B0%A9%EB%B2%95-Callback-Promise-async-await
        >> 어차피 콜백함수를 통해서 bind를 해도 이 함수들이 동시다발적으로 실행되는 것이 아니라 하나의 함수가 실행되고 연쇄적으로 실행되는거 아닌가요?

5. 블로킹과 논블로킹
    1. 블로킹 : 요청에 대한 응답을 보낼 때까지 제어권을 갖고 있는 것
    2. 논블로킹 : 어떤 요청이 들어왔을때 제어권을 요청을 보낸 쪽에 넘기고 요청을 한 쪽에 실행 권한을 부여하는 것